/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/gameRewards.js":
/*!****************************!*\
  !*** ./src/gameRewards.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   gameRewards: () => (/* binding */ gameRewards)\n/* harmony export */ });\n// Create a single instance for rewards.\r\nconst gameRewards = (function gameRewardsControl() {\r\n\r\n    // Reward scaler constant.\r\n    const REWARD_WEIGHT_SCALER = 10;\r\n\r\n    // Reward tiers\r\n    const symbolCategories = {\r\n        bigWins: ['7', 'üíé', 'üí∞'],  // High value symbols for big wins\r\n        mediumWins: ['üé∞', 'üîî', '‚≠ê'],  // Slot machine (wild) and other medium value symbols\r\n        smallWins: ['üçí', 'üçã', 'üçä', 'üçâ']  // Fruit symbols for small wins\r\n    };\r\n\r\n    // Reward Multipliers\r\n    const symbolWeights = {\r\n        bigWins: [10, 9, 8], // High value weights\r\n        mediumWins: [7, 6, 5], // Medium value weights\r\n        smallWins: [4, 3, 2, 1], // Small value weights\r\n    };\r\n\r\n    // const symbolToCategoryMap = Object.entries(symbolCategories).reduce((map, [category, symbols]) => {\r\n    //     symbols.forEach(symbol => {\r\n    //         map[symbol] = category;\r\n    //     });\r\n    //     return map;\r\n    // }, {});\r\n\r\n    const symbolToCategoryMap = {\r\n        \"7\": \"bigWins\",\r\n        \"üíé\": \"bigWins\",\r\n        \"üí∞\": \"bigWins\",\r\n        \"üé∞\": \"mediumWins\",\r\n        \"üîî\": \"mediumWins\",\r\n        \"‚≠ê\": \"mediumWins\",\r\n        \"üçí\": \"smallWins\",\r\n        \"üçã\": \"smallWins\",\r\n        \"üçä\": \"smallWins\",\r\n        \"üçâ\": \"smallWins\", \r\n    };\r\n\r\n    // Count the occurences of each symbol.\r\n    const countSymbolOccurrences = (results) => {\r\n        const resultsMap = new Map();\r\n        for (const symbol of results) {\r\n            resultsMap.set(symbol, (resultsMap.get(symbol) || 0) + 1);\r\n        }\r\n        return resultsMap;\r\n    };\r\n\r\n    // Check presence of wild symbol.\r\n    const checkForWildSymbol = (resultsMap) => {\r\n        let wildSymbol = symbolCategories.mediumWins[0];\r\n        if (resultsMap.has(wildSymbol)) {\r\n            if (resultsMap.get(wildSymbol) === 1) {\r\n                return true;\r\n            }\r\n            return false;\r\n        }\r\n        return false;\r\n    };    \r\n\r\n    // Replace wild symbol before evaluation.\r\n    const replaceWildSymbol = (resultsMap) => {\r\n        let wildSymbol = symbolCategories.mediumWins[0];\r\n        resultsMap.delete(wildSymbol); // Safe because `checkForWildSymbol` ensures existence\r\n        resultsMap.set(substituteWildSymbol(), 1);\r\n        return resultsMap;\r\n    };    \r\n\r\n    // Get a replacement for wild symbol\r\n    const substituteWildSymbol = () => {\r\n        const gameSymbols = ['üçí', 'üçã', 'üçä', 'üçâ', 'üé∞', 'üíé', 'üí∞', 'üîî', '‚≠ê', '7'];\r\n        const symbolPool = new Set();\r\n    \r\n        // Randomly populate a unique symbol pool\r\n        while (symbolPool.size < 10) {\r\n            const randomIndex = Math.floor(Math.random() * gameSymbols.length);\r\n            symbolPool.add(gameSymbols[randomIndex]);\r\n        }\r\n    \r\n        const poolArray = Array.from(symbolPool); // Convert Set to Array\r\n        const randomSymbol = poolArray[Math.floor(Math.random() * poolArray.length)]; // Pick a random symbol\r\n        return randomSymbol; // Return the substitutional symbol\r\n    };\r\n\r\n    const matchCategorizer = (resultsMap) => {\r\n        if (!(resultsMap instanceof Map)) {\r\n            throw new Error('Invalid input: resultsMap must be a Map');\r\n        }\r\n    \r\n        let matchCategory = null;\r\n        let resultsMapSize = resultsMap.size;\r\n    \r\n        switch (resultsMapSize) {\r\n            case 3:\r\n                matchCategory = 'No matching symbols';\r\n                break;\r\n            case 2:\r\n                matchCategory = '2 Matching symbols';\r\n                break;\r\n            case 1:\r\n                matchCategory = '3 Matching symbols';\r\n                break;\r\n            default:\r\n                matchCategory = 'Unknown category'; // Log or handle unexpected sizes explicitly\r\n        }\r\n    \r\n        return matchCategory;\r\n    };    \r\n\r\n    // Function to get the payout initiator key based on conditions\r\n    const getPayoutInitiatorKey = (resultsMap, searchValue = null) => {\r\n        for (let [key, value] of resultsMap) {\r\n            // Check for exact match\r\n            if (searchValue !== null && value === searchValue) {\r\n                return key;\r\n            }\r\n        }\r\n        \r\n        // Check for the first high-value symbol in bigWins category\r\n        for (let [key] of resultsMap) {\r\n            if (symbolCategories.bigWins.includes(key)) {\r\n                return key;\r\n            }\r\n        }\r\n\r\n        // Return null if no matching key is found\r\n        return null;\r\n    };\r\n\r\n    // Balance probability with payout\r\n    const payoutProbabilityBalancer = (resultsMap, matchCategory) => {\r\n        let payoutMultiplier = 0; // Default to no payout\r\n        let payoutInitiatorKey = null;\r\n\r\n        // Exit at early stages with defaults if no matching symbols present.\r\n        if (matchCategory === 'No matching symbols') return { payoutMultiplier, payoutInitiatorKey };\r\n        \r\n        // Assign multiplier and find initiator key based on match category\r\n        switch (matchCategory) {\r\n            case '3 Matching symbols':\r\n                payoutMultiplier = 1000; // Perfect Match: Bet√ó1000\r\n                payoutInitiatorKey = getPayoutInitiatorKey(resultsMap, 3);\r\n                break;\r\n\r\n            case '2 Matching symbols':\r\n                payoutMultiplier = 10; // Two Matching: Bet√ó10\r\n                payoutInitiatorKey = getPayoutInitiatorKey(resultsMap, 2);\r\n                break;\r\n\r\n            case 'No matching symbols':\r\n                payoutMultiplier = 2; // Special Single Match: Bet√ó2\r\n                payoutInitiatorKey = getPayoutInitiatorKey(resultsMap);\r\n                break;\r\n\r\n            default:\r\n                console.error(`Unknown match category: ${matchCategory}`);\r\n        }\r\n\r\n        return { payoutMultiplier, payoutInitiatorKey };\r\n    };\r\n\r\n    const getPayoutWeightingValue = (payoutInitiatorKey) => {\r\n        let payoutWeight = 0;\r\n    \r\n        // Determine the category group for the symbol\r\n        let paymentCategoryGroup = symbolToCategoryMap[payoutInitiatorKey];\r\n    \r\n        // Find the index of the symbol in the category group\r\n        let rewardSymbolIndex = symbolCategories[paymentCategoryGroup].indexOf(payoutInitiatorKey);\r\n    \r\n        // Retrieve the corresponding payout weight\r\n        payoutWeight = symbolWeights[paymentCategoryGroup][rewardSymbolIndex];\r\n    \r\n        return payoutWeight;\r\n    };       \r\n\r\n    // Reward assignments\r\n    const rewardAssignment = (results, betAmount) => {\r\n        console.log(\"Results:\", results);\r\n    \r\n        // Count occurrences of each symbol\r\n        let symbolOccurrences = countSymbolOccurrences(results);\r\n        console.log(\"Symbol Occurrences:\", symbolOccurrences);\r\n    \r\n        // Check and handle wild symbols\r\n        let wildSymbolPresence = checkForWildSymbol(symbolOccurrences);\r\n        console.log(\"Wild Symbol Presence:\", wildSymbolPresence);\r\n    \r\n        if (wildSymbolPresence) {\r\n            symbolOccurrences = replaceWildSymbol(symbolOccurrences); // Replace wild symbols in occurrences\r\n            console.log(\"Symbol Occurrences after Wild Replacement:\", symbolOccurrences);\r\n        }\r\n    \r\n        // Categorize match type\r\n        let matchCategory = matchCategorizer(symbolOccurrences);\r\n        console.log(\"Match Category:\", matchCategory);\r\n    \r\n        // Get payout details\r\n        let { payoutMultiplier, payoutInitiatorKey } = payoutProbabilityBalancer(symbolOccurrences, matchCategory);\r\n        console.log(\"Payout Multiplier:\", payoutMultiplier);\r\n        console.log(\"Payout Initiator Key:\", payoutInitiatorKey);\r\n    \r\n        // Return zero rewards if no valid payout\r\n        if (!payoutInitiatorKey || payoutMultiplier === 0) {\r\n            console.log(\"No valid payout.\");\r\n            return 0;\r\n        }\r\n    \r\n        // Determine payout weight and calculate final reward\r\n        let payoutWeightValue = getPayoutWeightingValue(payoutInitiatorKey);\r\n        console.log(\"Payout Weight Value:\", payoutWeightValue);\r\n    \r\n        // Reward calculation\r\n        let finalReward = betAmount * payoutMultiplier * (payoutWeightValue / REWARD_WEIGHT_SCALER);\r\n        console.log(`Reward Assigned: ${finalReward}`);\r\n        let winnings = betAmount + finalReward;\r\n        console.log(`Bet payouts: ${winnings}`)\r\n        return winnings ;\r\n    };    \r\n\r\n    // Add bonus features\r\n    // Wild symbol (one that can subsititute for another increase winning chanves)\r\n    // Jacpot 777\r\n\r\n    // Progressive elements \r\n    // Bet size influence (optionally give wild symbol for large bets)\r\n    // Cumulative rewards: progressive cumulative Jackpot\r\n\r\n    // Player history and tracking\r\n    // Use local storage for development\r\n    // Transition to DB once application is ready.\r\n\r\n    return { rewardAssignment };\r\n})();\r\n\r\n// Generate random bet amounts and random symbols for testing\r\nconst generateRandomTests = (numTests) => {\r\n    const possibleSymbols = ['üçí', 'üçã', 'üçä', 'üçâ', 'üé∞', 'üíé', 'üí∞', 'üîî', '‚≠ê', '7'];\r\n    const tests = [];\r\n\r\n    for (let i = 0; i < numTests; i++) {\r\n        // Generate a random bet amount between 10 and 1000\r\n        const betAmount = Math.floor(Math.random() * 991) + 10;\r\n\r\n        // Generate a random result array of 3 symbols\r\n        const results = Array.from({ length: 3 }, () => {\r\n            return possibleSymbols[Math.floor(Math.random() * possibleSymbols.length)];\r\n        });\r\n\r\n        tests.push({ betAmount, results });\r\n    }\r\n\r\n    return tests;\r\n};\r\n\r\n// Test gameRewards.rewardAssignment with 15 random cases\r\nconst randomTests = generateRandomTests(15);\r\n\r\nrandomTests.forEach(({ betAmount, results }, index) => {\r\n    console.log(`Test ${index + 1}:`);\r\n    console.log(`Bet Amount: ${betAmount}`);\r\n    console.log(`Results: ${results}`);\r\n    const winnings = gameRewards.rewardAssignment(results, betAmount);\r\n    console.log(`Winnings: ${winnings}`);\r\n    console.log('-----------------------------------');\r\n});\r\n\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvZ2FtZVJld2FyZHMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxRQUFRLElBQUk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRCxzRkFBc0Y7QUFDdEYsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELGNBQWM7QUFDdkU7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsdUNBQXVDO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxZQUFZO0FBQ3BEO0FBQ0Esb0NBQW9DLFNBQVM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxXQUFXO0FBQ2hEO0FBQ0EsU0FBUztBQUNUO0FBQ0EscUJBQXFCLG9CQUFvQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG9CQUFvQjtBQUMzQyx3QkFBd0IsVUFBVTtBQUNsQywrQkFBK0IsVUFBVTtBQUN6Qyw0QkFBNEIsUUFBUTtBQUNwQztBQUNBLDZCQUE2QixTQUFTO0FBQ3RDO0FBQ0EsQ0FBQztBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZGV2c3RhcnRidWlsZGluZy8uL3NyYy9nYW1lUmV3YXJkcy5qcz8wMWRkIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENyZWF0ZSBhIHNpbmdsZSBpbnN0YW5jZSBmb3IgcmV3YXJkcy5cclxuY29uc3QgZ2FtZVJld2FyZHMgPSAoZnVuY3Rpb24gZ2FtZVJld2FyZHNDb250cm9sKCkge1xyXG5cclxuICAgIC8vIFJld2FyZCBzY2FsZXIgY29uc3RhbnQuXHJcbiAgICBjb25zdCBSRVdBUkRfV0VJR0hUX1NDQUxFUiA9IDEwO1xyXG5cclxuICAgIC8vIFJld2FyZCB0aWVyc1xyXG4gICAgY29uc3Qgc3ltYm9sQ2F0ZWdvcmllcyA9IHtcclxuICAgICAgICBiaWdXaW5zOiBbJzcnLCAn8J+SjicsICfwn5KwJ10sICAvLyBIaWdoIHZhbHVlIHN5bWJvbHMgZm9yIGJpZyB3aW5zXHJcbiAgICAgICAgbWVkaXVtV2luczogWyfwn46wJywgJ/CflJQnLCAn4q2QJ10sICAvLyBTbG90IG1hY2hpbmUgKHdpbGQpIGFuZCBvdGhlciBtZWRpdW0gdmFsdWUgc3ltYm9sc1xyXG4gICAgICAgIHNtYWxsV2luczogWyfwn42SJywgJ/CfjYsnLCAn8J+NiicsICfwn42JJ10gIC8vIEZydWl0IHN5bWJvbHMgZm9yIHNtYWxsIHdpbnNcclxuICAgIH07XHJcblxyXG4gICAgLy8gUmV3YXJkIE11bHRpcGxpZXJzXHJcbiAgICBjb25zdCBzeW1ib2xXZWlnaHRzID0ge1xyXG4gICAgICAgIGJpZ1dpbnM6IFsxMCwgOSwgOF0sIC8vIEhpZ2ggdmFsdWUgd2VpZ2h0c1xyXG4gICAgICAgIG1lZGl1bVdpbnM6IFs3LCA2LCA1XSwgLy8gTWVkaXVtIHZhbHVlIHdlaWdodHNcclxuICAgICAgICBzbWFsbFdpbnM6IFs0LCAzLCAyLCAxXSwgLy8gU21hbGwgdmFsdWUgd2VpZ2h0c1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBjb25zdCBzeW1ib2xUb0NhdGVnb3J5TWFwID0gT2JqZWN0LmVudHJpZXMoc3ltYm9sQ2F0ZWdvcmllcykucmVkdWNlKChtYXAsIFtjYXRlZ29yeSwgc3ltYm9sc10pID0+IHtcclxuICAgIC8vICAgICBzeW1ib2xzLmZvckVhY2goc3ltYm9sID0+IHtcclxuICAgIC8vICAgICAgICAgbWFwW3N5bWJvbF0gPSBjYXRlZ29yeTtcclxuICAgIC8vICAgICB9KTtcclxuICAgIC8vICAgICByZXR1cm4gbWFwO1xyXG4gICAgLy8gfSwge30pO1xyXG5cclxuICAgIGNvbnN0IHN5bWJvbFRvQ2F0ZWdvcnlNYXAgPSB7XHJcbiAgICAgICAgXCI3XCI6IFwiYmlnV2luc1wiLFxyXG4gICAgICAgIFwi8J+SjlwiOiBcImJpZ1dpbnNcIixcclxuICAgICAgICBcIvCfkrBcIjogXCJiaWdXaW5zXCIsXHJcbiAgICAgICAgXCLwn46wXCI6IFwibWVkaXVtV2luc1wiLFxyXG4gICAgICAgIFwi8J+UlFwiOiBcIm1lZGl1bVdpbnNcIixcclxuICAgICAgICBcIuKtkFwiOiBcIm1lZGl1bVdpbnNcIixcclxuICAgICAgICBcIvCfjZJcIjogXCJzbWFsbFdpbnNcIixcclxuICAgICAgICBcIvCfjYtcIjogXCJzbWFsbFdpbnNcIixcclxuICAgICAgICBcIvCfjYpcIjogXCJzbWFsbFdpbnNcIixcclxuICAgICAgICBcIvCfjYlcIjogXCJzbWFsbFdpbnNcIiwgXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIENvdW50IHRoZSBvY2N1cmVuY2VzIG9mIGVhY2ggc3ltYm9sLlxyXG4gICAgY29uc3QgY291bnRTeW1ib2xPY2N1cnJlbmNlcyA9IChyZXN1bHRzKSA9PiB7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0c01hcCA9IG5ldyBNYXAoKTtcclxuICAgICAgICBmb3IgKGNvbnN0IHN5bWJvbCBvZiByZXN1bHRzKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdHNNYXAuc2V0KHN5bWJvbCwgKHJlc3VsdHNNYXAuZ2V0KHN5bWJvbCkgfHwgMCkgKyAxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdHNNYXA7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIENoZWNrIHByZXNlbmNlIG9mIHdpbGQgc3ltYm9sLlxyXG4gICAgY29uc3QgY2hlY2tGb3JXaWxkU3ltYm9sID0gKHJlc3VsdHNNYXApID0+IHtcclxuICAgICAgICBsZXQgd2lsZFN5bWJvbCA9IHN5bWJvbENhdGVnb3JpZXMubWVkaXVtV2luc1swXTtcclxuICAgICAgICBpZiAocmVzdWx0c01hcC5oYXMod2lsZFN5bWJvbCkpIHtcclxuICAgICAgICAgICAgaWYgKHJlc3VsdHNNYXAuZ2V0KHdpbGRTeW1ib2wpID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07ICAgIFxyXG5cclxuICAgIC8vIFJlcGxhY2Ugd2lsZCBzeW1ib2wgYmVmb3JlIGV2YWx1YXRpb24uXHJcbiAgICBjb25zdCByZXBsYWNlV2lsZFN5bWJvbCA9IChyZXN1bHRzTWFwKSA9PiB7XHJcbiAgICAgICAgbGV0IHdpbGRTeW1ib2wgPSBzeW1ib2xDYXRlZ29yaWVzLm1lZGl1bVdpbnNbMF07XHJcbiAgICAgICAgcmVzdWx0c01hcC5kZWxldGUod2lsZFN5bWJvbCk7IC8vIFNhZmUgYmVjYXVzZSBgY2hlY2tGb3JXaWxkU3ltYm9sYCBlbnN1cmVzIGV4aXN0ZW5jZVxyXG4gICAgICAgIHJlc3VsdHNNYXAuc2V0KHN1YnN0aXR1dGVXaWxkU3ltYm9sKCksIDEpO1xyXG4gICAgICAgIHJldHVybiByZXN1bHRzTWFwO1xyXG4gICAgfTsgICAgXHJcblxyXG4gICAgLy8gR2V0IGEgcmVwbGFjZW1lbnQgZm9yIHdpbGQgc3ltYm9sXHJcbiAgICBjb25zdCBzdWJzdGl0dXRlV2lsZFN5bWJvbCA9ICgpID0+IHtcclxuICAgICAgICBjb25zdCBnYW1lU3ltYm9scyA9IFsn8J+NkicsICfwn42LJywgJ/CfjYonLCAn8J+NiScsICfwn46wJywgJ/Cfko4nLCAn8J+SsCcsICfwn5SUJywgJ+KtkCcsICc3J107XHJcbiAgICAgICAgY29uc3Qgc3ltYm9sUG9vbCA9IG5ldyBTZXQoKTtcclxuICAgIFxyXG4gICAgICAgIC8vIFJhbmRvbWx5IHBvcHVsYXRlIGEgdW5pcXVlIHN5bWJvbCBwb29sXHJcbiAgICAgICAgd2hpbGUgKHN5bWJvbFBvb2wuc2l6ZSA8IDEwKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJhbmRvbUluZGV4ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogZ2FtZVN5bWJvbHMubGVuZ3RoKTtcclxuICAgICAgICAgICAgc3ltYm9sUG9vbC5hZGQoZ2FtZVN5bWJvbHNbcmFuZG9tSW5kZXhdKTtcclxuICAgICAgICB9XHJcbiAgICBcclxuICAgICAgICBjb25zdCBwb29sQXJyYXkgPSBBcnJheS5mcm9tKHN5bWJvbFBvb2wpOyAvLyBDb252ZXJ0IFNldCB0byBBcnJheVxyXG4gICAgICAgIGNvbnN0IHJhbmRvbVN5bWJvbCA9IHBvb2xBcnJheVtNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBwb29sQXJyYXkubGVuZ3RoKV07IC8vIFBpY2sgYSByYW5kb20gc3ltYm9sXHJcbiAgICAgICAgcmV0dXJuIHJhbmRvbVN5bWJvbDsgLy8gUmV0dXJuIHRoZSBzdWJzdGl0dXRpb25hbCBzeW1ib2xcclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgbWF0Y2hDYXRlZ29yaXplciA9IChyZXN1bHRzTWFwKSA9PiB7XHJcbiAgICAgICAgaWYgKCEocmVzdWx0c01hcCBpbnN0YW5jZW9mIE1hcCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGlucHV0OiByZXN1bHRzTWFwIG11c3QgYmUgYSBNYXAnKTtcclxuICAgICAgICB9XHJcbiAgICBcclxuICAgICAgICBsZXQgbWF0Y2hDYXRlZ29yeSA9IG51bGw7XHJcbiAgICAgICAgbGV0IHJlc3VsdHNNYXBTaXplID0gcmVzdWx0c01hcC5zaXplO1xyXG4gICAgXHJcbiAgICAgICAgc3dpdGNoIChyZXN1bHRzTWFwU2l6ZSkge1xyXG4gICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICBtYXRjaENhdGVnb3J5ID0gJ05vIG1hdGNoaW5nIHN5bWJvbHMnO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgIG1hdGNoQ2F0ZWdvcnkgPSAnMiBNYXRjaGluZyBzeW1ib2xzJztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICBtYXRjaENhdGVnb3J5ID0gJzMgTWF0Y2hpbmcgc3ltYm9scyc7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIG1hdGNoQ2F0ZWdvcnkgPSAnVW5rbm93biBjYXRlZ29yeSc7IC8vIExvZyBvciBoYW5kbGUgdW5leHBlY3RlZCBzaXplcyBleHBsaWNpdGx5XHJcbiAgICAgICAgfVxyXG4gICAgXHJcbiAgICAgICAgcmV0dXJuIG1hdGNoQ2F0ZWdvcnk7XHJcbiAgICB9OyAgICBcclxuXHJcbiAgICAvLyBGdW5jdGlvbiB0byBnZXQgdGhlIHBheW91dCBpbml0aWF0b3Iga2V5IGJhc2VkIG9uIGNvbmRpdGlvbnNcclxuICAgIGNvbnN0IGdldFBheW91dEluaXRpYXRvcktleSA9IChyZXN1bHRzTWFwLCBzZWFyY2hWYWx1ZSA9IG51bGwpID0+IHtcclxuICAgICAgICBmb3IgKGxldCBba2V5LCB2YWx1ZV0gb2YgcmVzdWx0c01hcCkge1xyXG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgZXhhY3QgbWF0Y2hcclxuICAgICAgICAgICAgaWYgKHNlYXJjaFZhbHVlICE9PSBudWxsICYmIHZhbHVlID09PSBzZWFyY2hWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGtleTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAvLyBDaGVjayBmb3IgdGhlIGZpcnN0IGhpZ2gtdmFsdWUgc3ltYm9sIGluIGJpZ1dpbnMgY2F0ZWdvcnlcclxuICAgICAgICBmb3IgKGxldCBba2V5XSBvZiByZXN1bHRzTWFwKSB7XHJcbiAgICAgICAgICAgIGlmIChzeW1ib2xDYXRlZ29yaWVzLmJpZ1dpbnMuaW5jbHVkZXMoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGtleTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUmV0dXJuIG51bGwgaWYgbm8gbWF0Y2hpbmcga2V5IGlzIGZvdW5kXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIEJhbGFuY2UgcHJvYmFiaWxpdHkgd2l0aCBwYXlvdXRcclxuICAgIGNvbnN0IHBheW91dFByb2JhYmlsaXR5QmFsYW5jZXIgPSAocmVzdWx0c01hcCwgbWF0Y2hDYXRlZ29yeSkgPT4ge1xyXG4gICAgICAgIGxldCBwYXlvdXRNdWx0aXBsaWVyID0gMDsgLy8gRGVmYXVsdCB0byBubyBwYXlvdXRcclxuICAgICAgICBsZXQgcGF5b3V0SW5pdGlhdG9yS2V5ID0gbnVsbDtcclxuXHJcbiAgICAgICAgLy8gRXhpdCBhdCBlYXJseSBzdGFnZXMgd2l0aCBkZWZhdWx0cyBpZiBubyBtYXRjaGluZyBzeW1ib2xzIHByZXNlbnQuXHJcbiAgICAgICAgaWYgKG1hdGNoQ2F0ZWdvcnkgPT09ICdObyBtYXRjaGluZyBzeW1ib2xzJykgcmV0dXJuIHsgcGF5b3V0TXVsdGlwbGllciwgcGF5b3V0SW5pdGlhdG9yS2V5IH07XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gQXNzaWduIG11bHRpcGxpZXIgYW5kIGZpbmQgaW5pdGlhdG9yIGtleSBiYXNlZCBvbiBtYXRjaCBjYXRlZ29yeVxyXG4gICAgICAgIHN3aXRjaCAobWF0Y2hDYXRlZ29yeSkge1xyXG4gICAgICAgICAgICBjYXNlICczIE1hdGNoaW5nIHN5bWJvbHMnOlxyXG4gICAgICAgICAgICAgICAgcGF5b3V0TXVsdGlwbGllciA9IDEwMDA7IC8vIFBlcmZlY3QgTWF0Y2g6IEJldMOXMTAwMFxyXG4gICAgICAgICAgICAgICAgcGF5b3V0SW5pdGlhdG9yS2V5ID0gZ2V0UGF5b3V0SW5pdGlhdG9yS2V5KHJlc3VsdHNNYXAsIDMpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBjYXNlICcyIE1hdGNoaW5nIHN5bWJvbHMnOlxyXG4gICAgICAgICAgICAgICAgcGF5b3V0TXVsdGlwbGllciA9IDEwOyAvLyBUd28gTWF0Y2hpbmc6IEJldMOXMTBcclxuICAgICAgICAgICAgICAgIHBheW91dEluaXRpYXRvcktleSA9IGdldFBheW91dEluaXRpYXRvcktleShyZXN1bHRzTWFwLCAyKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSAnTm8gbWF0Y2hpbmcgc3ltYm9scyc6XHJcbiAgICAgICAgICAgICAgICBwYXlvdXRNdWx0aXBsaWVyID0gMjsgLy8gU3BlY2lhbCBTaW5nbGUgTWF0Y2g6IEJldMOXMlxyXG4gICAgICAgICAgICAgICAgcGF5b3V0SW5pdGlhdG9yS2V5ID0gZ2V0UGF5b3V0SW5pdGlhdG9yS2V5KHJlc3VsdHNNYXApO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgVW5rbm93biBtYXRjaCBjYXRlZ29yeTogJHttYXRjaENhdGVnb3J5fWApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHsgcGF5b3V0TXVsdGlwbGllciwgcGF5b3V0SW5pdGlhdG9yS2V5IH07XHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnN0IGdldFBheW91dFdlaWdodGluZ1ZhbHVlID0gKHBheW91dEluaXRpYXRvcktleSkgPT4ge1xyXG4gICAgICAgIGxldCBwYXlvdXRXZWlnaHQgPSAwO1xyXG4gICAgXHJcbiAgICAgICAgLy8gRGV0ZXJtaW5lIHRoZSBjYXRlZ29yeSBncm91cCBmb3IgdGhlIHN5bWJvbFxyXG4gICAgICAgIGxldCBwYXltZW50Q2F0ZWdvcnlHcm91cCA9IHN5bWJvbFRvQ2F0ZWdvcnlNYXBbcGF5b3V0SW5pdGlhdG9yS2V5XTtcclxuICAgIFxyXG4gICAgICAgIC8vIEZpbmQgdGhlIGluZGV4IG9mIHRoZSBzeW1ib2wgaW4gdGhlIGNhdGVnb3J5IGdyb3VwXHJcbiAgICAgICAgbGV0IHJld2FyZFN5bWJvbEluZGV4ID0gc3ltYm9sQ2F0ZWdvcmllc1twYXltZW50Q2F0ZWdvcnlHcm91cF0uaW5kZXhPZihwYXlvdXRJbml0aWF0b3JLZXkpO1xyXG4gICAgXHJcbiAgICAgICAgLy8gUmV0cmlldmUgdGhlIGNvcnJlc3BvbmRpbmcgcGF5b3V0IHdlaWdodFxyXG4gICAgICAgIHBheW91dFdlaWdodCA9IHN5bWJvbFdlaWdodHNbcGF5bWVudENhdGVnb3J5R3JvdXBdW3Jld2FyZFN5bWJvbEluZGV4XTtcclxuICAgIFxyXG4gICAgICAgIHJldHVybiBwYXlvdXRXZWlnaHQ7XHJcbiAgICB9OyAgICAgICBcclxuXHJcbiAgICAvLyBSZXdhcmQgYXNzaWdubWVudHNcclxuICAgIGNvbnN0IHJld2FyZEFzc2lnbm1lbnQgPSAocmVzdWx0cywgYmV0QW1vdW50KSA9PiB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJSZXN1bHRzOlwiLCByZXN1bHRzKTtcclxuICAgIFxyXG4gICAgICAgIC8vIENvdW50IG9jY3VycmVuY2VzIG9mIGVhY2ggc3ltYm9sXHJcbiAgICAgICAgbGV0IHN5bWJvbE9jY3VycmVuY2VzID0gY291bnRTeW1ib2xPY2N1cnJlbmNlcyhyZXN1bHRzKTtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIlN5bWJvbCBPY2N1cnJlbmNlczpcIiwgc3ltYm9sT2NjdXJyZW5jZXMpO1xyXG4gICAgXHJcbiAgICAgICAgLy8gQ2hlY2sgYW5kIGhhbmRsZSB3aWxkIHN5bWJvbHNcclxuICAgICAgICBsZXQgd2lsZFN5bWJvbFByZXNlbmNlID0gY2hlY2tGb3JXaWxkU3ltYm9sKHN5bWJvbE9jY3VycmVuY2VzKTtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIldpbGQgU3ltYm9sIFByZXNlbmNlOlwiLCB3aWxkU3ltYm9sUHJlc2VuY2UpO1xyXG4gICAgXHJcbiAgICAgICAgaWYgKHdpbGRTeW1ib2xQcmVzZW5jZSkge1xyXG4gICAgICAgICAgICBzeW1ib2xPY2N1cnJlbmNlcyA9IHJlcGxhY2VXaWxkU3ltYm9sKHN5bWJvbE9jY3VycmVuY2VzKTsgLy8gUmVwbGFjZSB3aWxkIHN5bWJvbHMgaW4gb2NjdXJyZW5jZXNcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJTeW1ib2wgT2NjdXJyZW5jZXMgYWZ0ZXIgV2lsZCBSZXBsYWNlbWVudDpcIiwgc3ltYm9sT2NjdXJyZW5jZXMpO1xyXG4gICAgICAgIH1cclxuICAgIFxyXG4gICAgICAgIC8vIENhdGVnb3JpemUgbWF0Y2ggdHlwZVxyXG4gICAgICAgIGxldCBtYXRjaENhdGVnb3J5ID0gbWF0Y2hDYXRlZ29yaXplcihzeW1ib2xPY2N1cnJlbmNlcyk7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJNYXRjaCBDYXRlZ29yeTpcIiwgbWF0Y2hDYXRlZ29yeSk7XHJcbiAgICBcclxuICAgICAgICAvLyBHZXQgcGF5b3V0IGRldGFpbHNcclxuICAgICAgICBsZXQgeyBwYXlvdXRNdWx0aXBsaWVyLCBwYXlvdXRJbml0aWF0b3JLZXkgfSA9IHBheW91dFByb2JhYmlsaXR5QmFsYW5jZXIoc3ltYm9sT2NjdXJyZW5jZXMsIG1hdGNoQ2F0ZWdvcnkpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiUGF5b3V0IE11bHRpcGxpZXI6XCIsIHBheW91dE11bHRpcGxpZXIpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiUGF5b3V0IEluaXRpYXRvciBLZXk6XCIsIHBheW91dEluaXRpYXRvcktleSk7XHJcbiAgICBcclxuICAgICAgICAvLyBSZXR1cm4gemVybyByZXdhcmRzIGlmIG5vIHZhbGlkIHBheW91dFxyXG4gICAgICAgIGlmICghcGF5b3V0SW5pdGlhdG9yS2V5IHx8IHBheW91dE11bHRpcGxpZXIgPT09IDApIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJObyB2YWxpZCBwYXlvdXQuXCIpO1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICBcclxuICAgICAgICAvLyBEZXRlcm1pbmUgcGF5b3V0IHdlaWdodCBhbmQgY2FsY3VsYXRlIGZpbmFsIHJld2FyZFxyXG4gICAgICAgIGxldCBwYXlvdXRXZWlnaHRWYWx1ZSA9IGdldFBheW91dFdlaWdodGluZ1ZhbHVlKHBheW91dEluaXRpYXRvcktleSk7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJQYXlvdXQgV2VpZ2h0IFZhbHVlOlwiLCBwYXlvdXRXZWlnaHRWYWx1ZSk7XHJcbiAgICBcclxuICAgICAgICAvLyBSZXdhcmQgY2FsY3VsYXRpb25cclxuICAgICAgICBsZXQgZmluYWxSZXdhcmQgPSBiZXRBbW91bnQgKiBwYXlvdXRNdWx0aXBsaWVyICogKHBheW91dFdlaWdodFZhbHVlIC8gUkVXQVJEX1dFSUdIVF9TQ0FMRVIpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGBSZXdhcmQgQXNzaWduZWQ6ICR7ZmluYWxSZXdhcmR9YCk7XHJcbiAgICAgICAgbGV0IHdpbm5pbmdzID0gYmV0QW1vdW50ICsgZmluYWxSZXdhcmQ7XHJcbiAgICAgICAgY29uc29sZS5sb2coYEJldCBwYXlvdXRzOiAke3dpbm5pbmdzfWApXHJcbiAgICAgICAgcmV0dXJuIHdpbm5pbmdzIDtcclxuICAgIH07ICAgIFxyXG5cclxuICAgIC8vIEFkZCBib251cyBmZWF0dXJlc1xyXG4gICAgLy8gV2lsZCBzeW1ib2wgKG9uZSB0aGF0IGNhbiBzdWJzaXRpdHV0ZSBmb3IgYW5vdGhlciBpbmNyZWFzZSB3aW5uaW5nIGNoYW52ZXMpXHJcbiAgICAvLyBKYWNwb3QgNzc3XHJcblxyXG4gICAgLy8gUHJvZ3Jlc3NpdmUgZWxlbWVudHMgXHJcbiAgICAvLyBCZXQgc2l6ZSBpbmZsdWVuY2UgKG9wdGlvbmFsbHkgZ2l2ZSB3aWxkIHN5bWJvbCBmb3IgbGFyZ2UgYmV0cylcclxuICAgIC8vIEN1bXVsYXRpdmUgcmV3YXJkczogcHJvZ3Jlc3NpdmUgY3VtdWxhdGl2ZSBKYWNrcG90XHJcblxyXG4gICAgLy8gUGxheWVyIGhpc3RvcnkgYW5kIHRyYWNraW5nXHJcbiAgICAvLyBVc2UgbG9jYWwgc3RvcmFnZSBmb3IgZGV2ZWxvcG1lbnRcclxuICAgIC8vIFRyYW5zaXRpb24gdG8gREIgb25jZSBhcHBsaWNhdGlvbiBpcyByZWFkeS5cclxuXHJcbiAgICByZXR1cm4geyByZXdhcmRBc3NpZ25tZW50IH07XHJcbn0pKCk7XHJcblxyXG4vLyBHZW5lcmF0ZSByYW5kb20gYmV0IGFtb3VudHMgYW5kIHJhbmRvbSBzeW1ib2xzIGZvciB0ZXN0aW5nXHJcbmNvbnN0IGdlbmVyYXRlUmFuZG9tVGVzdHMgPSAobnVtVGVzdHMpID0+IHtcclxuICAgIGNvbnN0IHBvc3NpYmxlU3ltYm9scyA9IFsn8J+NkicsICfwn42LJywgJ/CfjYonLCAn8J+NiScsICfwn46wJywgJ/Cfko4nLCAn8J+SsCcsICfwn5SUJywgJ+KtkCcsICc3J107XHJcbiAgICBjb25zdCB0ZXN0cyA9IFtdO1xyXG5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtVGVzdHM7IGkrKykge1xyXG4gICAgICAgIC8vIEdlbmVyYXRlIGEgcmFuZG9tIGJldCBhbW91bnQgYmV0d2VlbiAxMCBhbmQgMTAwMFxyXG4gICAgICAgIGNvbnN0IGJldEFtb3VudCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDk5MSkgKyAxMDtcclxuXHJcbiAgICAgICAgLy8gR2VuZXJhdGUgYSByYW5kb20gcmVzdWx0IGFycmF5IG9mIDMgc3ltYm9sc1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiAzIH0sICgpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHBvc3NpYmxlU3ltYm9sc1tNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBwb3NzaWJsZVN5bWJvbHMubGVuZ3RoKV07XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRlc3RzLnB1c2goeyBiZXRBbW91bnQsIHJlc3VsdHMgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRlc3RzO1xyXG59O1xyXG5cclxuLy8gVGVzdCBnYW1lUmV3YXJkcy5yZXdhcmRBc3NpZ25tZW50IHdpdGggMTUgcmFuZG9tIGNhc2VzXHJcbmNvbnN0IHJhbmRvbVRlc3RzID0gZ2VuZXJhdGVSYW5kb21UZXN0cygxNSk7XHJcblxyXG5yYW5kb21UZXN0cy5mb3JFYWNoKCh7IGJldEFtb3VudCwgcmVzdWx0cyB9LCBpbmRleCkgPT4ge1xyXG4gICAgY29uc29sZS5sb2coYFRlc3QgJHtpbmRleCArIDF9OmApO1xyXG4gICAgY29uc29sZS5sb2coYEJldCBBbW91bnQ6ICR7YmV0QW1vdW50fWApO1xyXG4gICAgY29uc29sZS5sb2coYFJlc3VsdHM6ICR7cmVzdWx0c31gKTtcclxuICAgIGNvbnN0IHdpbm5pbmdzID0gZ2FtZVJld2FyZHMucmV3YXJkQXNzaWdubWVudChyZXN1bHRzLCBiZXRBbW91bnQpO1xyXG4gICAgY29uc29sZS5sb2coYFdpbm5pbmdzOiAke3dpbm5pbmdzfWApO1xyXG4gICAgY29uc29sZS5sb2coJy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tJyk7XHJcbn0pO1xyXG5cclxuZXhwb3J0IHsgZ2FtZVJld2FyZHMgfTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/gameRewards.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The require scope
/******/ 	var __webpack_require__ = {};
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./src/gameRewards.js"](0, __webpack_exports__, __webpack_require__);
/******/ 	
/******/ })()
;